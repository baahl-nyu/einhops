import torch
import einhops

# tests from https://web.archive.org/web/20250514130020/https://rockt.ai/2018/04/30/einsum

print("matrix transpose:")
a = torch.arange(6, dtype=torch.float32).reshape(2,3)
o = torch.einsum("ij->ji", a)
a_ckks = einhops.encrypt(a)
o_ckks = einhops.einsum("ij->ji", a_ckks)
print('torch:')
print(o)
print('einhops:')
print(einhops.decrypt(o_ckks))


print("\nsum")
a = torch.arange(6).reshape(2, 3)
o = torch.einsum('ij->', [a])
a_ckks = einhops.encrypt(a)
o_ckks = einhops.einsum("ij->", a_ckks)
print('torch:')
print(o)
print('einhops:')
print(einhops.decrypt(o_ckks))


print("\ncolumn sum")
a = torch.arange(6).reshape(2, 3)
o = torch.einsum('ij->j', [a])
a_ckks = einhops.encrypt(a)
o_ckks = einhops.einsum("ij->j", a_ckks)
print('torch:')
print(o)
print('einhops:')
print(einhops.decrypt(o_ckks))


print("\nrow sum")
a = torch.arange(6).reshape(2, 3)
o = torch.einsum('ij->i', [a])
a_ckks = einhops.encrypt(a)
o_ckks = einhops.einsum("ij->i", a_ckks)
print('torch:')
print(o)
print('einhops:')
print(einhops.decrypt(o_ckks))


print("\nmatvec mult")
a = torch.arange(6).reshape(2, 3)
b = torch.arange(3)
o = torch.einsum('ik,k->i', [a, b])
a_ckks = einhops.encrypt(a)
b_ckks = einhops.encrypt(b)
o_ckks = einhops.einsum("ik,k->i", a_ckks, b_ckks)
print('torch:')
print(o)
print('einhops:')
print(einhops.decrypt(o_ckks))


print("\nmatmatmul")
a = torch.arange(6).reshape(2, 3)
b = torch.arange(15).reshape(3, 5)
o = torch.einsum('ik,kj->ij', [a, b])
a_ckks = einhops.encrypt(a)
b_ckks = einhops.encrypt(b)
o_ckks = einhops.einsum("ik,kj->ij", a_ckks, b_ckks)
print('torch:')
print(o)
print('einhops:')
print(einhops.decrypt(o_ckks))


print("\ndot product")
a = torch.arange(3)
b = torch.arange(3,6)  # -- a vector of length 3 containing [3, 4, 5]
o = torch.einsum('i,i->', [a, b])
a_ckks = einhops.encrypt(a)
b_ckks = einhops.encrypt(b)
o_ckks = einhops.einsum("i,i->", a_ckks, b_ckks)
print('torch:')
print(o)
print('einhops:')
print(einhops.decrypt(o_ckks))


print("\ninner product")
a = torch.arange(6).reshape(2, 3)
b = torch.arange(6,12).reshape(2, 3)
o = torch.einsum('ij,ij->', [a, b])
a_ckks = einhops.encrypt(a)
b_ckks = einhops.encrypt(b)
o_ckks = einhops.einsum("ij,ij->", a_ckks, b_ckks)
print('torch:')
print(o)
print('einhops:')
print(einhops.decrypt(o_ckks))


print("\nhadamard product")
a = torch.arange(6).reshape(2, 3)
b = torch.arange(6,12).reshape(2, 3)
o = torch.einsum('ij,ij->ij', [a, b])
a_ckks = einhops.encrypt(a)
b_ckks = einhops.encrypt(b)
o_ckks = einhops.einsum("ij,ij->ij", a_ckks, b_ckks)
print('torch:')
print(o)
print('einhops:')
print(einhops.decrypt(o_ckks))

print("\nouter product")
a = torch.arange(3)
b = torch.arange(3,7)  # -- a vector of length 4 containing [3, 4, 5, 6]
o = torch.einsum('i,j->ij', [a, b])
a_ckks = einhops.encrypt(a)
b_ckks = einhops.encrypt(b)
o_ckks = einhops.einsum("i,j->ij", a_ckks, b_ckks)
print('torch:')
print(o)
print('einhops:')
print(einhops.decrypt(o_ckks))


print("\nbatched matmatmul")
a = torch.randn(3,2,5)
b = torch.randn(3,5,3)
o = torch.einsum('ijk,ikl->ijl', [a, b])
a_ckks = einhops.encrypt(a)
b_ckks = einhops.encrypt(b)
o_ckks = einhops.einsum("ijk,ikl->ijl", a_ckks, b_ckks)
print('torch:')
print(o)
print('einhops:')
print(einhops.decrypt(o_ckks))


print("\nthree-way hadamard mult")
a = torch.randn(2, 3)
b = torch.randn(2, 3)
c = torch.randn(2, 3)
o = torch.einsum('ij,ij,ij->ij', a, b, c)
a_ckks = einhops.encrypt(a)
b_ckks = einhops.encrypt(b)
c_ckks = einhops.encrypt(c)
o_ckks = einhops.einsum("ij,ij,ij->ij", a_ckks, b_ckks, c_ckks)
print('torch:')
print(o)
print('einhops:')
print(einhops.decrypt(o_ckks))


print("\nchained matmatmul")
a = torch.randn(2, 3)
b = torch.randn(3, 4)
c = torch.randn(4, 2)
o = torch.einsum('ij,jk,kl->il', a, b, c)
a_ckks = einhops.encrypt(a)
b_ckks = einhops.encrypt(b)
c_ckks = einhops.encrypt(c)
o_ckks = einhops.einsum("ij,jk,kl->il", a_ckks, b_ckks, c_ckks)
print('torch:')
print(o)
print('einhops:')
print(einhops.decrypt(o_ckks))


print("\nbilinear transform")
a = torch.randn(2,3)
b = torch.randn(5,3,7)
c = torch.randn(2,7)
o = torch.einsum('ik,jkl,il->ij', [a, b, c])
a_ckks = einhops.encrypt(a)
b_ckks = einhops.encrypt(b)
c_ckks = einhops.encrypt(c)
o_ckks = einhops.einsum("ik,jkl,il->ij", a_ckks, b_ckks, c_ckks)
print('torch:')
print(o)
print('einhops:')
print(einhops.decrypt(o_ckks))


print("\ntensor contraction")
a = torch.randn(2,3,5,7)
b = torch.randn(1,4,3,2,5)
o = torch.einsum('pqrs,tuqvr->pstuv', [a, b])
a_ckks = einhops.encrypt(a)
b_ckks = einhops.encrypt(b)
o_ckks = einhops.einsum("pqrs,tuqvr->pstuv", a_ckks, b_ckks)
print("L2:", torch.norm(o - einhops.decrypt(o_ckks)))
